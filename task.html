<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Daily Task Tracker</title>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css" />
  <style>
    @font-face {
      font-family: "Denton";
      src: url("./fonts/denton/Denton-Bold.woff2") format("woff2"),
           url("./fonts/denton/Denton-Bold.woff") format("woff");
      font-weight: 700;
      font-style: normal;
      font-display: swap;
    }

    @font-face {
      font-family: "InterLocal";
      src: url("./fonts/inter/inter-variablefont_slntwght-webfont.woff2") format("woff2"),
           url("./fonts/inter/inter-variablefont_slntwght-webfont.woff") format("woff");
      font-weight: 100 900;
      font-style: normal;
      font-display: swap;
    }

    :root {
      --font-heading: "Denton", "Georgia", serif;
      --font-body: "InterLocal", "Inter", "Segoe UI", system-ui, -apple-system, sans-serif;
      --bg: #eef7f3;
      --card: #ffffff;
      --surface: #f6fcf9;
      --surface-2: #edf9f3;
      --text: #113029;
      --muted: #4d6d63;
      --line: #d3e8dd;
      --line-2: #bedfd0;
      --brand: #0d8f5f;
      --brand-dark: #076845;
      --brand-soft: #e6f7ef;
      --danger: #c43333;
      --ok: #0f8a55;
    }

    * { box-sizing: border-box; }

    body {
      margin: 0;
      font-family: var(--font-body);
      background: radial-gradient(1000px 500px at 8% 0%, #d9f1e4, var(--bg) 55%);
      color: var(--text);
      min-height: 100vh;
      padding: 20px;
    }

    .container {
      width: min(1200px, 100%);
      margin: 0 auto;
      background: var(--card);
      border: 1px solid var(--line);
      border-radius: 18px;
      box-shadow: 0 26px 70px rgba(9, 30, 56, 0.15);
      overflow: hidden;
    }

    .header-main {
      display: grid;
      grid-template-columns: minmax(460px, 1.55fr) minmax(220px, 260px) minmax(360px, 420px);
      align-items: end;
      gap: 12px;
      padding: 18px 20px;
      border-bottom: 1px solid var(--line);
      background: linear-gradient(180deg, #ffffff 0%, #f6fcf9 100%);
    }

    .header-identity {
      display: grid;
      grid-template-columns: auto minmax(0, 1fr);
      align-items: start;
      gap: 14px;
      min-width: 0;
    }

    .brand-logo {
      width: 34px;
      height: 34px;
      border-radius: 8px;
      border: 1px solid var(--line);
      background: #fff;
      object-fit: contain;
      padding: 4px;
      box-shadow: 0 6px 14px rgba(17, 78, 55, 0.12);
    }

    .title-kicker {
      font-size: 12px;
      color: #4f7064;
      letter-spacing: 0.1em;
      text-transform: uppercase;
      font-weight: 700;
      margin: 0;
      white-space: nowrap;
    }

    .title-name {
      margin: 0;
      font-family: var(--font-heading);
      font-weight: 700;
      letter-spacing: 0.01em;
      font-size: clamp(30px, 3.2vw, 44px);
      line-height: 1.05;
      word-break: normal;
      overflow-wrap: normal;
      white-space: nowrap;
      font-size: clamp(24px, 2.4vw, 40px);
      text-overflow: ellipsis;
      overflow: hidden;
    }

    .title-dept {
      margin: 0;
      font-family: var(--font-body);
      font-size: 15px;
      color: var(--muted);
      line-height: 1.3;
    }

    .title {
      display: grid;
      gap: 4px;
      min-width: 0;
    }

    .header-date-status {
      display: grid;
      gap: 8px;
      min-width: 0;
      padding: 0 10px;
      border-left: 1px solid var(--line);
    }

    .date-input {
      display: grid;
      gap: 6px;
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: #55756a;
      width: 100%;
      max-width: none;
    }

    .date-input input[type="date"] {
      border-radius: 11px;
      border-color: #bfded0;
      background: #ffffff;
      font-size: 16px;
      font-weight: 600;
      padding: 10px 12px;
      min-height: 42px;
    }

    .header-actions {
      display: grid;
      grid-template-columns: auto auto;
      gap: 8px;
      justify-self: end;
      justify-content: end;
      align-items: center;
    }

    .header-actions .secondary {
      min-height: 42px;
      padding: 9px 12px;
    }

    .header-actions .sync-meta {
      grid-column: 1 / -1;
      margin-top: 2px;
      text-align: right;
    }

    input[type="date"],
    input[type="text"],
    input[type="number"],
    select,
    textarea {
      width: 100%;
      border: 1px solid var(--line);
      border-radius: 10px;
      padding: 10px 12px;
      font: inherit;
      color: var(--text);
      background: #ffffff;
      font-size: 15px;
      line-height: 1.3;
    }

    textarea {
      min-height: 70px;
      resize: vertical;
    }

    .split {
      display: grid;
      grid-template-columns: 1fr 1fr;
      min-height: 560px;
      background: linear-gradient(180deg, #f6fcf8 0%, #ebf7f1 100%);
    }

    .top-cards {
      display: grid;
      grid-template-columns: repeat(3, minmax(0, 1fr));
      gap: 12px;
      padding: 14px 16px;
      border-bottom: 1px solid var(--line);
      background: linear-gradient(180deg, #f8fdf9 0%, #f1faf4 100%);
    }

    .stat-card {
      border: 1px solid var(--line);
      border-radius: 14px;
      background: #ffffff;
      padding: 12px;
      box-shadow: 0 10px 20px rgba(12, 70, 48, 0.08);
      display: grid;
      gap: 6px;
    }

    .stat-title {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 12px;
      letter-spacing: 0.06em;
      text-transform: uppercase;
      color: var(--muted);
      font-weight: 700;
    }

    .stat-title i {
      color: var(--brand-dark);
    }

    .stat-value {
      font-size: 24px;
      font-family: var(--font-heading);
      line-height: 1;
    }

    .stat-sub {
      color: var(--muted);
      font-size: 12px;
    }

    .panel {
      padding: 0;
      display: grid;
      grid-template-rows: auto auto auto 1fr auto;
      gap: 12px;
      background: linear-gradient(180deg, #ffffff 0%, #f7fcf9 100%);
    }

    .panel + .panel {
      border-left: 1px solid var(--line);
      background: linear-gradient(180deg, #ffffff 0%, #f3faf6 100%);
    }

    .panel h2 {
      margin: 0;
      font-size: 18px;
      font-family: var(--font-heading);
      font-weight: 700;
    }

    .panel-title {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 16px 18px 0;
    }

    .panel-title i {
      color: var(--brand-dark);
      background: var(--brand-soft);
      border: 1px solid #bde7d4;
      width: 30px;
      height: 30px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      border-radius: 9px;
      font-size: 13px;
    }

    .panel p {
      margin: 0;
      font-size: 13px;
      color: var(--muted);
      padding: 0 18px;
    }

    .panel-input-area {
      padding: 0 18px;
    }

    .panel-list-area {
      padding: 0 18px;
      min-height: 0;
    }

    .panel-actions {
      position: sticky;
      bottom: 0;
      z-index: 4;
      border-top: 1px solid var(--line);
      background: linear-gradient(180deg, rgba(255,255,255,0.96) 0%, #f2fbf6 100%);
      backdrop-filter: blur(4px);
      padding: 12px 18px 14px;
      display: grid;
      gap: 8px;
    }

    .task-list {
      display: grid;
      gap: 10px;
      align-content: start;
      max-height: 480px;
      overflow: auto;
      padding-right: 3px;
      padding-bottom: 8px;
    }

    .task-row,
    .pending-row,
    .extra-row {
      border: 1px solid var(--line-2);
      border-radius: 14px;
      background: #fff;
      padding: 12px;
      display: grid;
      gap: 8px;
      box-shadow: 0 10px 20px rgba(18, 35, 61, 0.08);
      transition: transform 160ms ease, box-shadow 160ms ease, border-color 160ms ease;
      animation: cardIn 220ms ease both;
    }

    .task-row:hover,
    .pending-row:hover,
    .extra-row:hover {
      transform: translateY(-2px);
      box-shadow: 0 14px 26px rgba(13, 92, 64, 0.15);
      border-color: #9dd0ba;
    }

    .task-row-head,
    .pending-row-head,
    .extra-row-head {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
    }

    .task-title {
      font-size: 14px;
      font-weight: 700;
      word-break: break-word;
    }

    .task-title-wrap {
      display: flex;
      align-items: center;
      gap: 10px;
      min-width: 0;
    }

    .task-tags {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      flex-wrap: wrap;
    }

    .sr-badge {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      min-width: 42px;
      height: 24px;
      border-radius: 999px;
      background: var(--brand-soft);
      border: 1px solid #b7dfcd;
      color: #116445;
      font-size: 11px;
      font-weight: 700;
      letter-spacing: 0.05em;
      text-transform: uppercase;
      flex: 0 0 auto;
    }

    .priority {
      font-size: 11px;
      border: 1px solid #d2deec;
      border-radius: 999px;
      padding: 3px 9px;
      color: var(--muted);
      background: var(--surface);
    }

    .priority.low {
      background: #eef9f2;
      border-color: #cbe9d6;
      color: #246b45;
    }

    .priority.medium {
      background: #fff7eb;
      border-color: #f2ddb7;
      color: #855b1a;
    }

    .priority.high {
      background: #fff0f1;
      border-color: #f0c7cb;
      color: #9a2f39;
    }

    .meta-chip {
      font-size: 11px;
      border-radius: 999px;
      padding: 3px 9px;
      border: 1px solid var(--line);
      background: #f3faf6;
      color: #26624a;
      white-space: nowrap;
    }

    .meta-chip.prev {
      background: #f1fbf5;
      border-color: #c6e7d5;
      color: #1f6a49;
    }

    .meta-chip.locked {
      background: #e9f7ef;
      border-color: #bfe2cf;
      color: #14583b;
      font-weight: 600;
      min-width: 30px;
      text-align: center;
      padding: 3px 8px;
    }

    .action-row {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
    }

    button {
      border: 1px solid transparent;
      background: linear-gradient(180deg, var(--brand), var(--brand-dark));
      color: #fff;
      border-radius: 11px;
      padding: 10px 14px;
      font-weight: 600;
      cursor: pointer;
      font: inherit;
      line-height: 1.2;
      transition: transform 120ms ease, box-shadow 120ms ease, filter 120ms ease;
    }

    button i {
      margin-right: 6px;
      font-size: 13px;
    }

    button:hover:not(:disabled) {
      transform: translateY(-1px);
      box-shadow: 0 8px 18px rgba(8, 108, 68, 0.22);
      filter: saturate(1.02);
    }

    button.secondary {
      background: #eff8f3;
      color: var(--text);
      border-color: var(--line);
    }

    button.secondary:hover:not(:disabled) {
      box-shadow: 0 8px 18px rgba(22, 90, 62, 0.17);
    }

    button.danger {
      background: #fff;
      color: var(--danger);
      border-color: #efc6c6;
    }

    .icon-danger {
      width: 34px;
      height: 34px;
      padding: 0;
      border-radius: 10px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      line-height: 1;
    }

    .icon-danger i {
      margin: 0;
      font-size: 13px;
    }

    button:disabled {
      opacity: 0.55;
      cursor: not-allowed;
    }

    .inline {
      display: grid;
      grid-template-columns: 1fr 110px auto;
      gap: 8px;
      align-items: center;
    }

    .pending-select {
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .pending-select input[type="checkbox"] {
      width: 18px;
      height: 18px;
      accent-color: var(--brand);
      cursor: pointer;
    }

    .pending-meta,
    .extra-meta {
      display: grid;
      grid-template-columns: 130px 92px 92px 1fr;
      gap: 8px;
      align-items: start;
      border-top: 1px dashed var(--line);
      padding-top: 10px;
    }

    .meta-field {
      display: grid;
      gap: 6px;
      min-width: 0;
    }

    .meta-field > label {
      font-size: 11px;
      letter-spacing: 0.06em;
      text-transform: uppercase;
      color: var(--muted);
      font-weight: 700;
      line-height: 1;
    }

    .meta-field.note-field textarea {
      min-height: 68px;
    }

    .meta-field.has-error > label {
      color: #af2c2c;
    }

    .meta-field.has-error input,
    .meta-field.has-error select,
    .meta-field.has-error textarea {
      border-color: #d64b4b;
      box-shadow: 0 0 0 2px rgba(214, 75, 75, 0.12);
    }

    .field-error {
      color: #b12f2f;
      font-size: 11px;
      line-height: 1.25;
    }

    .pending-meta input[type="number"],
    .extra-meta input[type="number"] {
      text-align: center;
      padding: 9px 10px;
      font-weight: 600;
    }

    .muted {
      color: var(--muted);
      font-size: 12px;
    }

    .sod-source {
      margin-top: 0;
      font-size: 11px;
      color: #4b6d61;
      letter-spacing: 0.01em;
      padding: 6px 8px;
      border: 1px solid #d5e8de;
      border-radius: 8px;
      background: #fcfffd;
    }

    .sync-meta {
      font-size: 11px;
      color: #4f7165;
      padding: 0 2px;
      line-height: 1.4;
    }

    .toast-stack {
      position: fixed;
      right: 18px;
      bottom: 18px;
      z-index: 1200;
      display: grid;
      gap: 8px;
      width: min(320px, calc(100vw - 24px));
      pointer-events: none;
    }

    .toast {
      border: 1px solid var(--line);
      border-left-width: 4px;
      border-radius: 10px;
      background: #ffffff;
      box-shadow: 0 14px 28px rgba(9, 46, 63, 0.16);
      padding: 10px 12px;
      font-size: 13px;
      color: var(--text);
      animation: toastIn 180ms ease forwards;
    }

    .toast.success { border-left-color: var(--ok); }
    .toast.error { border-left-color: var(--danger); }
    .toast.info { border-left-color: #1d4f91; }

    .toast.out {
      animation: toastOut 160ms ease forwards;
    }

    .btn-loading i {
      animation: spin 800ms linear infinite;
    }

    .sod-buckets {
      display: flex;
      align-items: center;
      gap: 8px;
      flex-wrap: wrap;
      margin-top: 8px;
    }

    .bucket-chip {
      border: 1px solid var(--line);
      border-radius: 999px;
      background: #f3faf7;
      color: #336252;
      font-size: 11px;
      padding: 3px 10px;
      letter-spacing: 0.03em;
      text-transform: uppercase;
      font-weight: 600;
    }

    .task-section-title {
      font-size: 12px;
      color: #4f6f64;
      text-transform: uppercase;
      letter-spacing: 0.06em;
      font-weight: 700;
      margin: 4px 0 2px;
    }

    .progress-hint {
      margin-top: 6px;
      font-size: 11px;
      color: #56766a;
      border-top: 1px dashed var(--line);
      padding-top: 6px;
    }

    .status {
      font-size: 13px;
      min-height: 18px;
    }

    .status.error { color: var(--danger); }
    .status.success { color: var(--ok); }
    .status.info { color: #1d4f91; }

    .empty {
      border: 1px dashed #cbd7e7;
      border-radius: 12px;
      padding: 14px;
      background: var(--surface);
      color: var(--muted);
      font-size: 13px;
    }

    .blocked {
      position: fixed;
      inset: 0;
      background: rgba(8, 16, 28, 0.75);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 999;
      padding: 16px;
    }

    .blocked.active { display: flex; }

    .blocked-card {
      width: min(520px, 100%);
      background: #fff;
      border-radius: 14px;
      border: 1px solid #e8d1d1;
      padding: 18px;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.2);
    }

    .blocked-card h3 {
      margin: 0 0 8px;
      color: #9b1c1c;
    }

    .blocked-card p {
      margin: 0;
      color: #5c2020;
      line-height: 1.5;
      font-size: 14px;
    }

    .title h1 i,
    .identity-line i {
      color: #1f7552;
      margin-right: 6px;
    }

    input:focus,
    textarea:focus {
      outline: none;
      border-color: #5cae89;
      box-shadow: 0 0 0 3px rgba(31, 144, 95, 0.18);
    }

    @keyframes cardIn {
      from { opacity: 0; transform: translateY(6px); }
      to { opacity: 1; transform: translateY(0); }
    }

    @keyframes toastIn {
      from { opacity: 0; transform: translateY(8px); }
      to { opacity: 1; transform: translateY(0); }
    }

    @keyframes toastOut {
      from { opacity: 1; transform: translateY(0); }
      to { opacity: 0; transform: translateY(8px); }
    }

    @keyframes spin {
      from { transform: rotate(0deg); }
      to { transform: rotate(360deg); }
    }

    @media (prefers-reduced-motion: reduce) {
      *, *::before, *::after {
        animation: none !important;
        transition: none !important;
        scroll-behavior: auto !important;
      }
    }

    @media (max-width: 980px) {
      .header-main {
        grid-template-columns: 1fr;
        gap: 10px;
      }

      .header-date-status {
        border: none;
        padding: 0;
      }

      .header-actions {
        justify-self: start;
        justify-content: start;
        grid-template-columns: 1fr;
      }

      .title-kicker {
        white-space: normal;
      }

      .top-cards {
        grid-template-columns: 1fr;
      }

      .split {
        grid-template-columns: 1fr;
      }

      .panel + .panel {
        border-left: none;
        border-top: 1px solid var(--line);
      }

      .panel-actions {
        position: static;
      }

      .pending-meta,
      .extra-meta,
      .inline {
        grid-template-columns: 1fr;
      }
    }
  </style>
</head>
<body>
  <div id="blocked" class="blocked" aria-hidden="true">
    <div class="blocked-card">
      <h3>Invalid access link</h3>
      <p id="blockedMsg">This page requires valid URL parameters: department, name, and access code.</p>
    </div>
  </div>

  <main id="app" class="container" hidden>
    <section class="header-main">
      <div class="header-identity">
        <img src="./fonts/Finnovate-logo-F.png" alt="Finnovate" class="brand-logo" />
        <div class="title">
          <p class="title-kicker">Daily Task Submission For</p>
          <h1 id="nameLine" class="title-name">-</h1>
          <p id="deptLine" class="title-dept">Department: -</p>
        </div>
      </div>
      <div class="header-date-status">
        <label class="date-input">
          Date
          <input id="workDate" type="date" />
        </label>
        <div id="sodSourceHint" class="sod-source">Carryover source: -</div>
      </div>
      <div class="header-actions">
        <button id="syncCarryoverBtn" type="button" class="secondary"><i class="fa-solid fa-rotate"></i>Sync Now</button>
        <button id="copySummaryLinkBtn" type="button" class="secondary"><i class="fa-solid fa-link"></i>Copy Summary Link</button>
        <div id="syncMetaLine" class="sync-meta">Sync: Not run</div>
      </div>
    </section>

    <section class="top-cards">
      <article class="stat-card">
        <div class="stat-title"><i class="fa-solid fa-sun"></i>Start Of Day</div>
        <div id="startCountCard" class="stat-value">0</div>
        <div class="stat-sub">Planned tasks</div>
      </article>
      <article class="stat-card">
        <div class="stat-title"><i class="fa-regular fa-clock"></i>Total Hours Split</div>
        <div id="hoursSplitCard" class="stat-value">0h 0m</div>
        <div class="stat-sub">Dedicated time on selected completed tasks</div>
      </article>
      <article class="stat-card">
        <div class="stat-title"><i class="fa-solid fa-moon"></i>End Of Day</div>
        <div id="endCountCard" class="stat-value">0</div>
        <div class="stat-sub">Tasks selected for completion update</div>
      </article>
    </section>

    <section class="split">
      <section class="panel" aria-label="Start of Day">
        <h2 class="panel-title"><i class="fa-solid fa-sun"></i>Start of Day</h2>
        <p>Add the pending task list for today, then submit.</p>

        <div class="panel-input-area">
          <div class="inline">
            <input id="newTaskTitle" type="text" placeholder="Add task title" />
            <select id="newTaskPriority" aria-label="Task Priority">
              <option value="Low">Low</option>
              <option value="Medium" selected>Medium</option>
              <option value="High">High</option>
            </select>
            <button id="addTaskBtn" class="secondary" type="button"><i class="fa-solid fa-plus"></i>Add Task</button>
          </div>
          <div class="muted" style="margin-top:6px;">Priority can be Low, Medium, or High.</div>
          <div id="sodBuckets" class="sod-buckets"></div>
        </div>

        <div class="panel-list-area">
          <div id="sodTasks" class="task-list"></div>
        </div>

        <div class="panel-actions">
          <div id="sodStatus" class="status"></div>
          <div class="action-row">
            <button id="submitSodBtn" type="button"><i class="fa-solid fa-paper-plane"></i>Submit Start of Day</button>
          </div>
        </div>
      </section>

      <section class="panel" aria-label="End of Day">
        <h2 class="panel-title"><i class="fa-solid fa-moon"></i>End of Day</h2>
        <p>Select pending tasks, add completion %, and mention dedicated hours/minutes.</p>

        <div class="panel-input-area">
          <div class="action-row">
            <button id="addExtraBtn" type="button" class="secondary"><i class="fa-solid fa-list-plus"></i>Add Extra Task</button>
          </div>
        </div>

        <div class="panel-list-area">
          <div id="eodTasks" class="task-list"></div>
        </div>

        <div class="panel-actions">
          <div id="eodStatus" class="status"></div>
          <div class="action-row">
            <button id="submitEodBtn" type="button"><i class="fa-solid fa-flag-checkered"></i>Submit End of Day</button>
          </div>
        </div>
      </section>
    </section>
  </main>
  <div id="toastStack" class="toast-stack" aria-live="polite" aria-atomic="false"></div>

  <script>
    const APPS_SCRIPT_URL = "https://script.google.com/macros/s/AKfycbyGiugBUVbg9zp4r6QYSqHveJotVgYo0Rg9iGef7sovksfiupICN2LlBbiqSoVAqxAcFg/exec";
    const ZOHO_FLOW_WEBHOOK_URL = "https://flow.zoho.in/60027533273/flow/webhook/incoming?zapikey=1001.262d73321ec4cf092dc34d6310e3dee8.f22019fbcce0c6084f92ac9de2262976&isdebug=false";
    const STORAGE_PREFIX = "dailyTaskTrackerV4";
    const CLIENT_VERSION = "task-ui-v4";
    const USER_DIRECTORY = {
      "Information Technology": {
        "Shalin Bhavsar": "IT-SB-7391",
        "Pranav Shah": "IT-PS-1842",
        "Anoj Tambe": "IT-AT-5627",
        "Gunjan Rusia": "IT-GR-9034",
        "Thakur Prasad": "IT-TP-4478"
      },
      Operations: {
        "Pravin Mayekar": "OP-PM-2749",
        "Rahul Meher": "OP-RM-6183",
        "Nagma Sheikh": "OP-NS-8501",
        "Amit Lad": "OP-AL-3926",
        "Akshay Jadhav": "OP-AJ-7754"
      },
      Research: {
        "Riya Jain": "RS-RJ-5318",
        "Rushabh Dugad": "RS-RD-9620",
        "Humaid Khot": "RS-HK-4175",
        "Yash Asrani": "RS-YA-2864",
        "Vinjal Rao": "RS-VR-6412",
        "Ria Ignatious": "RS-RI-8097"
      },
      Equity: {
        "Gaurav Haldankar": "EQ-GH-1539",
        "Milind Jain": "EQ-MJ-7204",
        "Jinal Shah": "EQ-JS-4981"
      },
      "Direct Reportees": {
        "Pranob Thachanthara": "DR-PT-3328",
        "Rajvi Gori": "DR-RG-6815",
        "Chintan Dudhela": "DR-CD-9043",
        "Sagar Maheshwari": "DR-SM-2576",
        "Jignesh Gajjar": "DR-JG-5462",
        "Jayant Furia": "DR-JF-1198",
        "Vandana Manwani": "DR-VM-8730"
      }
    };

    const appEl = document.getElementById("app");
    const blockedEl = document.getElementById("blocked");
    const blockedMsgEl = document.getElementById("blockedMsg");
    const nameLineEl = document.getElementById("nameLine");
    const deptLineEl = document.getElementById("deptLine");
    const workDateEl = document.getElementById("workDate");
    const startCountCardEl = document.getElementById("startCountCard");
    const hoursSplitCardEl = document.getElementById("hoursSplitCard");
    const endCountCardEl = document.getElementById("endCountCard");
    const toastStackEl = document.getElementById("toastStack");

    const newTaskTitleEl = document.getElementById("newTaskTitle");
    const newTaskPriorityEl = document.getElementById("newTaskPriority");
    const addTaskBtn = document.getElementById("addTaskBtn");
    const submitSodBtn = document.getElementById("submitSodBtn");
    const sodStatusEl = document.getElementById("sodStatus");
    const sodTasksEl = document.getElementById("sodTasks");
    const sodSourceHintEl = document.getElementById("sodSourceHint");
    const syncMetaLineEl = document.getElementById("syncMetaLine");
    const sodBucketsEl = document.getElementById("sodBuckets");
    const syncCarryoverBtn = document.getElementById("syncCarryoverBtn");
    const copySummaryLinkBtn = document.getElementById("copySummaryLinkBtn");

    const addExtraBtn = document.getElementById("addExtraBtn");
    const submitEodBtn = document.getElementById("submitEodBtn");
    const eodStatusEl = document.getElementById("eodStatus");
    const eodTasksEl = document.getElementById("eodTasks");
    const COMPLETION_OPTIONS = [10, 25, 50, 75, 90, 100];

    let identity = null;
    let state = null;

    function todayISO() {
      return new Date().toISOString().slice(0, 10);
    }

    function nextDateISO(isoDate) {
      const [y, m, d] = (isoDate || todayISO()).split("-").map(Number);
      const dt = new Date(y, (m || 1) - 1, d || 1);
      dt.setDate(dt.getDate() + 1);
      const yy = String(dt.getFullYear());
      const mm = String(dt.getMonth() + 1).padStart(2, "0");
      const dd = String(dt.getDate()).padStart(2, "0");
      return `${yy}-${mm}-${dd}`;
    }

    function previousDateISO(isoDate) {
      const [y, m, d] = (isoDate || todayISO()).split("-").map(Number);
      const dt = new Date(y, (m || 1) - 1, d || 1);
      dt.setDate(dt.getDate() - 1);
      const yy = String(dt.getFullYear());
      const mm = String(dt.getMonth() + 1).padStart(2, "0");
      const dd = String(dt.getDate()).padStart(2, "0");
      return `${yy}-${mm}-${dd}`;
    }

    function createRequestId() {
      return `req-${Date.now()}-${Math.random().toString(36).slice(2, 10)}`;
    }

    function formatDateTime(ts) {
      if (!ts) return "-";
      const d = new Date(ts);
      if (Number.isNaN(d.getTime())) return "-";
      return d.toLocaleString();
    }

    function createTaskId() {
      if (window.crypto && typeof window.crypto.randomUUID === "function") {
        return window.crypto.randomUUID();
      }
      return `task-${Date.now()}-${Math.random().toString(16).slice(2, 10)}`;
    }

    function normalizePriority(raw) {
      const v = (raw || "").trim().toLowerCase();
      if (v === "low") return "Low";
      if (v === "high") return "High";
      return "Medium";
    }

    function priorityClass(priority) {
      const p = normalizePriority(priority).toLowerCase();
      return p === "low" || p === "high" ? p : "medium";
    }

    function getAccessParams() {
      const params = new URLSearchParams(window.location.search);
      return {
        dept: (params.get("dept") || "").trim(),
        name: (params.get("name") || "").trim(),
        code: (params.get("code") || "").trim(),
      };
    }

    function getStorageKey() {
      return `${STORAGE_PREFIX}:${identity.dept}:${identity.name}`;
    }

    function defaultState() {
      return {
        workDate: todayISO(),
        startDraftByDate: {},
        startSourceByDate: {},
        syncMetaByDate: {},
        sodByDate: {},
        eodSubmittedByDate: {},
        eodDraftByDate: {},
        carryoverByDate: {},
        carryoverSourceByDate: {},
        carryoverSyncedByDate: {},
        assignmentByDate: {},
        assignmentSyncedByDate: {}
      };
    }

    function loadState() {
      const raw = localStorage.getItem(getStorageKey());
      if (!raw) return defaultState();
      try {
        const parsed = JSON.parse(raw);
        if (!parsed || typeof parsed !== "object") return defaultState();
        return {
          workDate: parsed.workDate || todayISO(),
          startDraftByDate: parsed.startDraftByDate || {},
          startSourceByDate: parsed.startSourceByDate || {},
          syncMetaByDate: parsed.syncMetaByDate || {},
          sodByDate: parsed.sodByDate || {},
          eodSubmittedByDate: parsed.eodSubmittedByDate || {},
          eodDraftByDate: parsed.eodDraftByDate || {},
          carryoverByDate: parsed.carryoverByDate || {},
          carryoverSourceByDate: parsed.carryoverSourceByDate || {},
          carryoverSyncedByDate: parsed.carryoverSyncedByDate || {},
          assignmentByDate: parsed.assignmentByDate || {},
          assignmentSyncedByDate: parsed.assignmentSyncedByDate || {}
        };
      } catch (e) {
        return defaultState();
      }
    }

    function saveState() {
      localStorage.setItem(getStorageKey(), JSON.stringify(state));
    }

    function setStatus(el, message, type) {
      el.className = "status";
      if (type) el.classList.add(type);
      el.textContent = message || "";
    }

    function showToast(message, type = "info", durationMs = 2400) {
      if (!toastStackEl) return;
      const toast = document.createElement("div");
      toast.className = `toast ${type}`;
      toast.textContent = String(message || "");
      toastStackEl.appendChild(toast);
      setTimeout(() => {
        toast.classList.add("out");
        setTimeout(() => {
          if (toast.parentNode) toast.parentNode.removeChild(toast);
        }, 180);
      }, durationMs);
    }

    function setButtonLoading(button, loading, loadingLabel, normalLabel) {
      if (!button) return;
      if (loading) {
        if (!button.dataset.labelNormal) {
          button.dataset.labelNormal = normalLabel || button.innerHTML;
        }
        button.disabled = true;
        button.classList.add("btn-loading");
        button.innerHTML = `<i class="fa-solid fa-spinner"></i>${loadingLabel || "Loading..."}`;
        return;
      }
      button.disabled = false;
      button.classList.remove("btn-loading");
      button.innerHTML = normalLabel || button.dataset.labelNormal || button.innerHTML;
    }

    function getOrCreateStartDraft(dateKey) {
      if (!state.startDraftByDate[dateKey]) {
        const carry = Array.isArray(state.carryoverByDate[dateKey]) ? state.carryoverByDate[dateKey] : [];
        state.startDraftByDate[dateKey] = carry.map((t) => ({
          taskId: t.taskId || createTaskId(),
          title: t.title || "",
          priority: normalizePriority(t.priority),
          source: "carryover",
          lastCompletion: Number.isFinite(Number(t.lastCompletion)) ? Number(t.lastCompletion) : null,
          lastNote: t.lastNote || "",
          carryoverOrigin: String(t.carryoverOrigin || state.carryoverSourceByDate[dateKey] || "local-storage")
        }));
        if (carry.length) {
          state.startSourceByDate[dateKey] = state.carryoverSourceByDate[dateKey] === "google-sheets"
            ? "google-sheets"
            : "local-storage";
        } else if (!state.startSourceByDate[dateKey]) {
          state.startSourceByDate[dateKey] = "new";
        }
      }
      return state.startDraftByDate[dateKey];
    }

    function getCarryoverLastCompletion(task) {
      const n = Number(task && task.lastCompletion);
      return Number.isFinite(n) ? n : null;
    }

    function isCarryoverTask(task) {
      return task && task.source === "carryover";
    }

    function isAssignedTask(task) {
      return task && task.source === "assigned";
    }

    function isLockedStartTask(task) {
      return isCarryoverTask(task) || isAssignedTask(task);
    }

    function getAllowedCompletionOptions(task) {
      const prev = getCarryoverLastCompletion(task);
      if (!isCarryoverTask(task) || prev === null) return [...COMPLETION_OPTIONS];
      const filtered = COMPLETION_OPTIONS.filter((v) => v > prev);
      if (filtered.length) return filtered;
      return [100];
    }

    function buildCompletionOptionsMarkup(values) {
      return [
        "<option value=\"\">Select</option>",
        ...values.map((v) => `<option value=\"${v}\">${v}</option>`)
      ].join("");
    }

    function focusEditorField(editorId, field) {
      window.requestAnimationFrame(() => {
        setTimeout(() => {
          const esc = (v) => (window.CSS && typeof CSS.escape === "function")
            ? CSS.escape(v)
            : String(v).replace(/["\\]/g, "\\$&");
          const selector = `[data-editor-id="${esc(editorId)}"][data-field="${esc(field)}"]`;
          const el = document.querySelector(selector);
          if (!el) return;
          if (typeof el.scrollIntoView === "function") {
            el.scrollIntoView({ behavior: "smooth", block: "center" });
          }
          el.focus({ preventScroll: false });
          if (typeof el.select === "function" && (el.tagName === "INPUT" || el.tagName === "TEXTAREA")) {
            el.select();
          }
        }, 0);
      });
    }

    function getPendingTasksForDate(dateKey) {
      if (state.eodSubmittedByDate[dateKey]) return [];
      const submitted = Array.isArray(state.sodByDate[dateKey]) ? state.sodByDate[dateKey] : [];
      if (submitted.length) return submitted;
      return getOrCreateStartDraft(dateKey);
    }

    function mergeCarryoverIntoStartDraft(dateKey, carryoverTasks) {
      const existing = Array.isArray(state.startDraftByDate[dateKey]) ? state.startDraftByDate[dateKey] : [];
      const byKey = new Map();
      const taskKey = (t) => {
        const id = String(t && t.taskId || "").trim();
        const title = String(t && t.title || "").trim().toLowerCase();
        return id ? `id:${id}` : `title:${title}`;
      };

      carryoverTasks.forEach((t) => {
        byKey.set(taskKey(t), {
          taskId: t.taskId || createTaskId(),
          title: (t.title || "").trim(),
          priority: normalizePriority(t.priority),
          source: "carryover",
          lastCompletion: Number.isFinite(Number(t.lastCompletion)) ? Number(t.lastCompletion) : null,
          lastNote: String(t.lastNote || "").trim(),
          carryoverOrigin: String(t.carryoverOrigin || "local-storage")
        });
      });

      existing.forEach((t) => {
        const key = taskKey(t);
        if (byKey.has(key)) return;
        const source = isCarryoverTask(t) ? "carryover" : (isAssignedTask(t) ? "assigned" : "sod");
        byKey.set(key, {
          taskId: t.taskId || createTaskId(),
          title: (t.title || "").trim(),
          priority: normalizePriority(t.priority),
          source,
          lastCompletion: isCarryoverTask(t) ? getCarryoverLastCompletion(t) : null,
          lastNote: isCarryoverTask(t) ? String(t.lastNote || "").trim() : "",
          carryoverOrigin: isCarryoverTask(t) ? String(t.carryoverOrigin || "local-storage") : "",
          assignedBy: isAssignedTask(t) ? String(t.assignedBy || "").trim() : ""
        });
      });

      state.startDraftByDate[dateKey] = Array.from(byKey.values()).filter((t) => t.title.length > 0);
    }

    function hydrateCarryoverFromUnsubmittedSod(dateKey) {
      const prevDate = previousDateISO(dateKey);
      const prevSod = Array.isArray(state.sodByDate[prevDate]) ? state.sodByDate[prevDate] : [];
      const prevDraft = Array.isArray(state.startDraftByDate[prevDate]) ? state.startDraftByDate[prevDate] : [];
      const prevTasks = prevSod.length ? prevSod : prevDraft;
      if (!prevTasks.length) return false;
      if (state.eodSubmittedByDate[prevDate]) return false;

      const fallbackTasks = prevTasks
        .map((t) => ({
          taskId: t.taskId || createTaskId(),
          title: String(t.title || "").trim(),
          priority: normalizePriority(t.priority),
          source: "carryover",
          carryFrom: prevDate,
          lastCompletion: Number.isFinite(Number(t.lastCompletion)) ? Number(t.lastCompletion) : 0,
          lastNote: String(t.lastNote || "").trim() || "Auto carryover (previous day EOD not submitted).",
          carryoverOrigin: "auto-unsubmitted-eod"
        }))
        .filter((t) => t.title.length > 0);

      if (!fallbackTasks.length) return false;

      const existing = Array.isArray(state.carryoverByDate[dateKey]) ? state.carryoverByDate[dateKey] : [];
      const map = new Map();
      const keyOf = (t) => {
        const id = String(t && t.taskId || "").trim();
        const title = String(t && t.title || "").trim().toLowerCase();
        return id ? `id:${id}` : `title:${title}`;
      };

      existing.forEach((t) => map.set(keyOf(t), { ...t }));
      fallbackTasks.forEach((t) => {
        const k = keyOf(t);
        if (!map.has(k)) {
          map.set(k, t);
          return;
        }
        const current = map.get(k) || {};
        const curProgress = Number.isFinite(Number(current.lastCompletion)) ? Number(current.lastCompletion) : 0;
        const nextProgress = Number.isFinite(Number(t.lastCompletion)) ? Number(t.lastCompletion) : 0;
        if (nextProgress > curProgress) {
          map.set(k, { ...current, ...t });
        }
      });

      const merged = Array.from(map.values()).filter((t) => String(t.title || "").trim().length > 0);
      state.carryoverByDate[dateKey] = merged;
      if (!state.carryoverSourceByDate[dateKey]) {
        state.carryoverSourceByDate[dateKey] = "local-storage";
      }
      if (!state.startSourceByDate[dateKey]) {
        state.startSourceByDate[dateKey] = "local-storage";
      }
      mergeCarryoverIntoStartDraft(dateKey, fallbackTasks);
      return true;
    }

    function mergeAssignmentsIntoStartDraft(dateKey, assignmentTasks) {
      const existing = Array.isArray(state.startDraftByDate[dateKey]) ? state.startDraftByDate[dateKey] : [];
      const byKey = new Map();
      const keyOf = (t) => {
        const id = String(t && t.taskId || "").trim();
        const title = String(t && t.title || "").trim().toLowerCase();
        return id ? `id:${id}` : `title:${title}`;
      };

      assignmentTasks.forEach((t) => {
        byKey.set(keyOf(t), {
          taskId: t.taskId || createTaskId(),
          title: String(t.title || "").trim(),
          priority: normalizePriority(t.priority),
          source: "assigned",
          assignedBy: String(t.assignedBy || "").trim(),
          assignedAt: String(t.assignedAt || "").trim()
        });
      });

      existing.forEach((t) => {
        const key = keyOf(t);
        if (byKey.has(key)) return;
        byKey.set(key, { ...t });
      });

      state.startDraftByDate[dateKey] = Array.from(byKey.values()).filter((t) => String(t.title || "").trim().length > 0);
    }

    function mergeAssignmentsIntoSubmittedSod(dateKey, assignmentTasks) {
      const existing = Array.isArray(state.sodByDate[dateKey]) ? state.sodByDate[dateKey] : [];
      if (!existing.length) return;

      const byKey = new Map();
      const keyOf = (t) => {
        const id = String(t && t.taskId || "").trim();
        const title = String(t && t.title || "").trim().toLowerCase();
        return id ? `id:${id}` : `title:${title}`;
      };

      existing.forEach((t) => {
        byKey.set(keyOf(t), { ...t });
      });

      assignmentTasks.forEach((t) => {
        const k = keyOf(t);
        if (byKey.has(k)) return;
        byKey.set(k, {
          taskId: t.taskId || createTaskId(),
          title: String(t.title || "").trim(),
          priority: normalizePriority(t.priority),
          source: "assigned",
          assignedBy: String(t.assignedBy || "").trim(),
          assignedAt: String(t.assignedAt || "").trim()
        });
      });

      state.sodByDate[dateKey] = Array.from(byKey.values()).filter((t) => String(t.title || "").trim().length > 0);
    }

    async function syncAssignmentsFromAdmin(dateKey, force = false) {
      if (!identity || !dateKey) return;
      if (!force && state.assignmentSyncedByDate[dateKey]) return;

      try {
        const result = await callApiJsonp("getAssignments", {
          workDate: dateKey,
          department: identity.dept,
          employeeName: identity.name,
          accessCode: identity.code,
          clientVersion: CLIENT_VERSION
        }, 12000);

        if (!result || result.ok === false) {
          throw new Error(result && result.message ? result.message : "Assignment fetch rejected.");
        }

        const assignments = ensureArray(result.tasks)
          .map((t) => ({
            taskId: t.taskId || createTaskId(),
            title: String(t.title || "").trim(),
            priority: normalizePriority(t.priority),
            source: "assigned",
            assignedBy: String(t.assignedBy || "").trim(),
            assignedAt: String(t.assignedAt || "").trim()
          }))
          .filter((t) => t.title.length > 0);

        state.assignmentByDate[dateKey] = assignments;
        if (assignments.length) {
          mergeAssignmentsIntoSubmittedSod(dateKey, assignments);
          mergeAssignmentsIntoStartDraft(dateKey, assignments);
          state.startSourceByDate[dateKey] = state.startSourceByDate[dateKey] === "google-sheets"
            ? "google-sheets"
            : "local-storage";
        }
        state.assignmentSyncedByDate[dateKey] = true;
        saveState();
      } catch (err) {
        saveState();
      }
    }

    function getOrCreateEodDraft(dateKey) {
      if (!state.eodDraftByDate[dateKey]) {
        state.eodDraftByDate[dateKey] = {
          selectedTaskIds: {},
          updatesByTaskId: {},
          extras: [],
          activeEditorId: "",
          fieldErrors: {}
        };
      }
      if (typeof state.eodDraftByDate[dateKey].activeEditorId !== "string") {
        state.eodDraftByDate[dateKey].activeEditorId = "";
      }
      if (!state.eodDraftByDate[dateKey].fieldErrors || typeof state.eodDraftByDate[dateKey].fieldErrors !== "object") {
        state.eodDraftByDate[dateKey].fieldErrors = {};
      }
      return state.eodDraftByDate[dateKey];
    }

    function showBlocked(message) {
      blockedMsgEl.textContent = message;
      blockedEl.classList.add("active");
      blockedEl.setAttribute("aria-hidden", "false");
      appEl.hidden = true;
      submitSodBtn.disabled = true;
      submitEodBtn.disabled = true;
    }

    function toFormEncoded(payload) {
      const params = new URLSearchParams();
      Object.keys(payload).forEach((key) => {
        const val = payload[key];
        if (val == null) {
          params.append(key, "");
        } else if (typeof val === "object") {
          params.append(key, JSON.stringify(val));
        } else {
          params.append(key, String(val));
        }
      });
      return params.toString();
    }

    function isCorsLikeNetworkError(err) {
      const msg = String(err && err.message ? err.message : err).toLowerCase();
      return msg.includes("networkerror")
        || msg.includes("failed to fetch")
        || msg.includes("load failed")
        || msg.includes("cors");
    }

    async function callApi(action, payload, options = {}) {
      const allowNoCorsFallback = options.allowNoCorsFallback !== false;
      const body = { action, ...payload };
      try {
        const response = await fetch(APPS_SCRIPT_URL, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(body)
        });
        const text = await response.text();
        let data = {};
        try {
          data = text ? JSON.parse(text) : {};
        } catch (e) {
          data = { raw: text };
        }
        if (!response.ok) {
          throw new Error(data.message || `HTTP ${response.status}`);
        }
        return data;
      } catch (err) {
        if (!allowNoCorsFallback || !isCorsLikeNetworkError(err)) throw err;
        await fetch(APPS_SCRIPT_URL, {
          method: "POST",
          mode: "no-cors",
          headers: { "Content-Type": "application/x-www-form-urlencoded;charset=UTF-8" },
          body: toFormEncoded(body),
          keepalive: true
        });
        return { ok: true, transport: "no-cors" };
      }
    }

    function callApiJsonp(action, payload, timeoutMs = 12000) {
      return new Promise((resolve, reject) => {
        const callbackName = `jsonp_${Date.now()}_${Math.random().toString(36).slice(2, 8)}`;
        const params = new URLSearchParams({ action, callback: callbackName });
        Object.entries(payload || {}).forEach(([key, val]) => {
          params.append(key, val == null ? "" : String(val));
        });
        const src = `${APPS_SCRIPT_URL}?${params.toString()}`;
        const script = document.createElement("script");
        let settled = false;
        const cleanup = () => {
          if (script.parentNode) script.parentNode.removeChild(script);
          delete window[callbackName];
        };
        const timer = setTimeout(() => {
          if (settled) return;
          settled = true;
          cleanup();
          reject(new Error("Carryover request timed out."));
        }, timeoutMs);

        window[callbackName] = (data) => {
          if (settled) return;
          settled = true;
          clearTimeout(timer);
          cleanup();
          resolve(data || {});
        };
        script.onerror = () => {
          if (settled) return;
          settled = true;
          clearTimeout(timer);
          cleanup();
          reject(new Error("Could not load Apps Script JSONP response."));
        };
        script.src = src;
        script.async = true;
        document.head.appendChild(script);
      });
    }

    function normalizeCarryoverPayload(result) {
      const raw = Array.isArray(result && result.tasks) ? result.tasks
        : Array.isArray(result && result.carryoverTasks) ? result.carryoverTasks
        : [];
      return raw
        .map((t) => ({
          taskId: t.taskId || createTaskId(),
          title: (t.title || t.task || "").trim(),
          priority: normalizePriority(t.priority),
          source: "carryover",
          lastCompletion: t.lastCompletion,
          lastNote: t.lastNote,
          carryoverOrigin: "google-sheets"
        }))
        .filter((t) => t.title.length > 0);
    }

    async function fetchCarryoverWithRetry(payload, maxAttempts = 2) {
      let lastError = null;
      for (let attempt = 1; attempt <= maxAttempts; attempt += 1) {
        try {
          const result = await callApiJsonp("getCarryover", payload, 12000 + (attempt - 1) * 5000);
          if (!result || result.ok === false) {
            throw new Error(result && result.message ? result.message : "Carryover fetch rejected.");
          }
          return { result, attempts: attempt };
        } catch (err) {
          lastError = err;
        }
      }
      throw lastError || new Error("Carryover sync failed.");
    }

    function setSyncMeta(dateKey, meta) {
      state.syncMetaByDate[dateKey] = {
        at: new Date().toISOString(),
        status: meta.status || "idle",
        attempts: Number(meta.attempts || 0),
        message: String(meta.message || "")
      };
    }

    async function syncCarryoverFromSheets(dateKey, force = false) {
      if (!identity || !dateKey) return;
      if (!force && state.carryoverSyncedByDate[dateKey]) return;
      if (Array.isArray(state.sodByDate[dateKey]) && state.sodByDate[dateKey].length) {
        state.carryoverSyncedByDate[dateKey] = true;
        setSyncMeta(dateKey, { status: "skipped", message: "Skipped (SOD already submitted for this date)." });
        saveState();
        return;
      }

      try {
        const { result, attempts } = await fetchCarryoverWithRetry({
          workDate: dateKey,
          department: identity.dept,
          employeeName: identity.name,
          accessCode: identity.code,
          clientVersion: CLIENT_VERSION
        });

        const carryoverTasks = normalizeCarryoverPayload(result);
        if (carryoverTasks.length) {
          state.carryoverByDate[dateKey] = carryoverTasks;
          state.carryoverSourceByDate[dateKey] = "google-sheets";
          mergeCarryoverIntoStartDraft(dateKey, carryoverTasks);
          state.startSourceByDate[dateKey] = "google-sheets";
          setSyncMeta(dateKey, { status: "success", attempts, message: `Synced ${carryoverTasks.length} carryover task(s) from Google Sheets.` });
        } else {
          state.carryoverByDate[dateKey] = [];
          delete state.carryoverSourceByDate[dateKey];
          const usedFallback = hydrateCarryoverFromUnsubmittedSod(dateKey);
          if (usedFallback) {
            state.carryoverSourceByDate[dateKey] = "local-storage";
            state.startSourceByDate[dateKey] = "local-storage";
            setSyncMeta(dateKey, {
              status: "fallback",
              attempts,
              message: "Google Sheets returned no carryover. Using previous day SOD because EOD was not submitted."
            });
          } else {
            if (!state.startSourceByDate[dateKey]) {
              state.startSourceByDate[dateKey] = "new";
            }
            setSyncMeta(dateKey, { status: "success", attempts, message: "No carryover tasks found." });
          }
        }

        state.carryoverSyncedByDate[dateKey] = true;
        saveState();
      } catch (err) {
        const usedFallback = hydrateCarryoverFromUnsubmittedSod(dateKey);
        if (Array.isArray(state.carryoverByDate[dateKey]) && state.carryoverByDate[dateKey].length) {
          state.carryoverSourceByDate[dateKey] = "local-storage";
          if (!state.startSourceByDate[dateKey]) {
            state.startSourceByDate[dateKey] = "local-storage";
          }
          setSyncMeta(dateKey, {
            status: "fallback",
            message: usedFallback
              ? "Using previous day SOD because EOD was not submitted."
              : "Using local carryover fallback."
          });
        } else {
          setSyncMeta(dateKey, { status: "error", message: String(err && err.message ? err.message : err) });
        }
        saveState();
        setStatus(sodStatusEl, "Could not pull carryover from Google Sheets. Showing local carryover fallback.", "info");
      }
    }

    function renderSodSourceHint() {
      const dateKey = workDateEl.value;
      const submitted = Array.isArray(state.sodByDate[dateKey]) ? state.sodByDate[dateKey] : [];
      const draft = getOrCreateStartDraft(dateKey);
      const source = state.startSourceByDate[dateKey] || "new";
      const assignedCount = Array.isArray(state.assignmentByDate[dateKey]) ? state.assignmentByDate[dateKey].length : 0;
      const assignedPart = assignedCount ? ` | Admin assigned: ${assignedCount}` : "";

      if (submitted.length) {
        sodSourceHintEl.textContent = `Carryover source: Local storage${assignedPart}`;
        return;
      }
      if (!draft.length && source === "new") {
        sodSourceHintEl.textContent = `Carryover source: Not loaded yet${assignedPart}`;
        return;
      }
      if (source === "google-sheets") {
        sodSourceHintEl.textContent = `Carryover source: Google Sheets${assignedPart}`;
        return;
      }
      sodSourceHintEl.textContent = `Carryover source: Local storage${assignedPart}`;
    }

    function renderSyncMeta() {
      const dateKey = workDateEl.value;
      const meta = state.syncMetaByDate[dateKey];
      if (!meta) {
        syncMetaLineEl.textContent = "Sync: Not run";
        return;
      }
      const label = meta.status === "success" ? "Success"
        : meta.status === "fallback" ? "Fallback"
        : meta.status === "error" ? "Failed"
        : meta.status === "skipped" ? "Skipped"
        : "Info";
      const tries = meta.attempts ? ` | Attempts: ${meta.attempts}` : "";
      syncMetaLineEl.textContent = `Sync: ${label} | ${formatDateTime(meta.at)}${tries}${meta.message ? ` | ${meta.message}` : ""}`;
    }

    function renderStartTasks() {
      const dateKey = workDateEl.value;
      const tasks = getOrCreateStartDraft(dateKey);
      sodTasksEl.innerHTML = "";
      const assignedTasks = tasks.filter((t) => isAssignedTask(t));
      const carryoverTasks = tasks.filter((t) => isCarryoverTask(t));
      const newTasks = tasks.filter((t) => !isCarryoverTask(t) && !isAssignedTask(t));
      sodBucketsEl.innerHTML = "";
      const assignedChip = document.createElement("span");
      assignedChip.className = "bucket-chip";
      assignedChip.textContent = `Assigned ${assignedTasks.length}`;
      sodBucketsEl.appendChild(assignedChip);
      const carryChip = document.createElement("span");
      carryChip.className = "bucket-chip";
      carryChip.textContent = `Carryover ${carryoverTasks.length}`;
      const newChip = document.createElement("span");
      newChip.className = "bucket-chip";
      newChip.textContent = `New ${newTasks.length}`;
      sodBucketsEl.appendChild(carryChip);
      sodBucketsEl.appendChild(newChip);

      if (!tasks.length) {
        const empty = document.createElement("div");
        empty.className = "empty";
        empty.textContent = "No tasks yet. Add your first task above.";
        sodTasksEl.appendChild(empty);
        return;
      }

      let srIndex = 0;
      const renderSection = (titleText, list) => {
        if (!list.length) return;
        const section = document.createElement("div");
        section.className = "task-section-title";
        section.textContent = titleText;
        sodTasksEl.appendChild(section);
        list.forEach((task) => {
          srIndex += 1;
          renderTask(task, srIndex);
        });
      };

      const renderTask = (task, index) => {
        const isCarryover = isCarryoverTask(task);
        const isAssigned = isAssignedTask(task);
        const prevCompletion = getCarryoverLastCompletion(task);
        const row = document.createElement("div");
        row.className = "task-row";

        const head = document.createElement("div");
        head.className = "task-row-head";

        const titleWrap = document.createElement("div");
        titleWrap.className = "task-title-wrap";
        const sr = document.createElement("span");
        sr.className = "sr-badge";
        sr.textContent = `#${String(index).padStart(2, "0")}`;
        const title = document.createElement("div");
        title.className = "task-title";
        title.textContent = task.title;
        titleWrap.appendChild(sr);
        titleWrap.appendChild(title);

        const right = document.createElement("div");
        right.className = "task-tags";

        const priority = document.createElement("span");
        const normalizedPriority = normalizePriority(task.priority);
        priority.className = `priority ${priorityClass(normalizedPriority)}`;
        priority.textContent = normalizedPriority;

        right.appendChild(priority);
        if (isLockedStartTask(task)) {
          const lockedChip = document.createElement("span");
          lockedChip.className = "meta-chip locked";
          lockedChip.title = isAssigned ? "Locked assigned task" : "Locked carryover task";
          lockedChip.setAttribute("aria-label", isAssigned ? "Locked assigned task" : "Locked carryover task");
          lockedChip.innerHTML = "<i class=\"fa-solid fa-lock\"></i>";
          right.appendChild(lockedChip);
        }
        if (isAssigned && task.assignedBy) {
          const assignChip = document.createElement("span");
          assignChip.className = "meta-chip";
          assignChip.textContent = `Assigned by ${task.assignedBy}`;
          right.appendChild(assignChip);
        }
        if (prevCompletion !== null) {
          const prevChip = document.createElement("span");
          prevChip.className = "meta-chip prev";
          prevChip.textContent = `Prev: ${prevCompletion}%`;
          right.appendChild(prevChip);
        }
        if (!isLockedStartTask(task)) {
          const remove = document.createElement("button");
          remove.type = "button";
          remove.className = "danger icon-danger";
          remove.title = "Remove task";
          remove.setAttribute("aria-label", "Remove task");
          remove.innerHTML = "<i class=\"fa-solid fa-trash\"></i>";
          remove.addEventListener("click", () => {
            tasks.splice(index, 1);
            saveState();
            renderStartTasks();
            renderEodTasks();
            updateSummaryCards();
          });
          right.appendChild(remove);
        }
        head.appendChild(titleWrap);
        head.appendChild(right);
        row.appendChild(head);

        sodTasksEl.appendChild(row);
      };

      renderSection("Admin Assigned", assignedTasks);
      renderSection("Locked Carryover", carryoverTasks);
      renderSection("New Tasks Added Today", newTasks);
    }

    function getFieldError(eodDraft, editorId, field) {
      return eodDraft.fieldErrors
        && eodDraft.fieldErrors[editorId]
        && eodDraft.fieldErrors[editorId][field]
        ? String(eodDraft.fieldErrors[editorId][field])
        : "";
    }

    function clearFieldError(eodDraft, editorId, field) {
      if (!eodDraft.fieldErrors || !eodDraft.fieldErrors[editorId]) return;
      delete eodDraft.fieldErrors[editorId][field];
      if (!Object.keys(eodDraft.fieldErrors[editorId]).length) {
        delete eodDraft.fieldErrors[editorId];
      }
    }

    function setFieldError(eodDraft, editorId, field, message) {
      if (!eodDraft.fieldErrors) eodDraft.fieldErrors = {};
      if (!eodDraft.fieldErrors[editorId]) eodDraft.fieldErrors[editorId] = {};
      eodDraft.fieldErrors[editorId][field] = String(message || "");
    }

    function renderEodTasks() {
      const dateKey = workDateEl.value;
      const pending = getPendingTasksForDate(dateKey);
      const eodDraft = getOrCreateEodDraft(dateKey);
      (eodDraft.extras || []).forEach((extra) => {
        if (!extra.taskId) extra.taskId = createTaskId();
      });

      const validEditorIds = new Set([
        ...pending.map((t) => `pending:${t.taskId}`),
        ...(eodDraft.extras || []).map((e) => `extra:${e.taskId}`)
      ]);

      let activeEditorId = eodDraft.activeEditorId || "";
      if (activeEditorId && !validEditorIds.has(activeEditorId)) {
        activeEditorId = "";
      }

      if (!activeEditorId) {
        const firstSelectedPending = pending.find((t) => eodDraft.selectedTaskIds[t.taskId]);
        if (firstSelectedPending) {
          activeEditorId = `pending:${firstSelectedPending.taskId}`;
        } else if (pending.length) {
          const first = pending[0];
          eodDraft.selectedTaskIds[first.taskId] = true;
          if (!eodDraft.updatesByTaskId[first.taskId]) {
            eodDraft.updatesByTaskId[first.taskId] = { completionPercent: "", spentHours: "", spentMinutes: "", note: "" };
          }
          activeEditorId = `pending:${first.taskId}`;
        } else if ((eodDraft.extras || []).length) {
          activeEditorId = `extra:${eodDraft.extras[0].taskId}`;
        }
        eodDraft.activeEditorId = activeEditorId;
        saveState();
      }

      eodTasksEl.innerHTML = "";

      if (!pending.length && !eodDraft.extras.length) {
        const empty = document.createElement("div");
        empty.className = "empty";
        empty.textContent = "No pending tasks. Submit Start of Day tasks first, or add an extra task.";
        eodTasksEl.appendChild(empty);
      }

      pending.forEach((task) => {
        const editorId = `pending:${task.taskId}`;
        const row = document.createElement("div");
        row.className = "pending-row";
        const allowedCompletion = getAllowedCompletionOptions(task);

        const head = document.createElement("div");
        head.className = "pending-row-head";

        const sel = document.createElement("label");
        sel.className = "pending-select";
        const checkbox = document.createElement("input");
        checkbox.type = "checkbox";
        checkbox.checked = Boolean(eodDraft.selectedTaskIds[task.taskId]);
        const sr = document.createElement("span");
        sr.className = "sr-badge";
        sr.textContent = `#${String(eodTasksEl.querySelectorAll(".pending-row").length + 1).padStart(2, "0")}`;
        const title = document.createElement("span");
        title.className = "task-title";
        title.textContent = task.title;
        sel.appendChild(checkbox);
        sel.appendChild(sr);
        sel.appendChild(title);

        const pri = document.createElement("span");
        const normalizedPriority = normalizePriority(task.priority);
        pri.className = `priority ${priorityClass(normalizedPriority)}`;
        pri.textContent = normalizedPriority;

        head.appendChild(sel);
        head.appendChild(pri);
        row.appendChild(head);
        if (isCarryoverTask(task) && getCarryoverLastCompletion(task) !== null) {
          const hint = document.createElement("div");
          hint.className = "progress-hint";
          hint.textContent = `Prev ${getCarryoverLastCompletion(task)}% | Allowed now: ${allowedCompletion.join(", ")}%`;
          row.appendChild(hint);
        }

        const meta = document.createElement("div");
        meta.className = "pending-meta";
        meta.style.display = checkbox.checked && activeEditorId === editorId ? "grid" : "none";

        const percent = document.createElement("select");
        percent.innerHTML = buildCompletionOptionsMarkup(allowedCompletion);

        const spentHours = document.createElement("input");
        spentHours.type = "number";
        spentHours.min = "0";
        spentHours.placeholder = "Hours";

        const spentMinutes = document.createElement("input");
        spentMinutes.type = "number";
        spentMinutes.min = "0";
        spentMinutes.max = "59";
        spentMinutes.placeholder = "Minutes";

        const note = document.createElement("textarea");
        note.placeholder = "Optional progress note";

        const existing = eodDraft.updatesByTaskId[task.taskId] || { completionPercent: "", spentHours: "", spentMinutes: "", note: "" };
        const existingCompletion = existing.completionPercent == null ? "" : String(existing.completionPercent);
        const existingAllowed = existingCompletion !== "" && allowedCompletion.includes(Number(existingCompletion));
        percent.value = existingAllowed ? existingCompletion : "";
        if (existingCompletion !== "" && !existingAllowed && eodDraft.updatesByTaskId[task.taskId]) {
          eodDraft.updatesByTaskId[task.taskId].completionPercent = "";
        }
        percent.dataset.editorId = editorId;
        percent.dataset.field = "completionPercent";
        if (isCarryoverTask(task) && getCarryoverLastCompletion(task) >= 100) {
          percent.disabled = true;
          percent.value = "100";
        }
        spentHours.value = existing.spentHours;
        spentHours.dataset.editorId = editorId;
        spentHours.dataset.field = "spentHours";
        spentMinutes.value = existing.spentMinutes;
        spentMinutes.dataset.editorId = editorId;
        spentMinutes.dataset.field = "spentMinutes";
        note.value = existing.note;
        note.dataset.editorId = editorId;
        note.dataset.field = "note";

        const percentField = document.createElement("div");
        percentField.className = "meta-field";
        const percentError = getFieldError(eodDraft, editorId, "completionPercent");
        if (percentError) percentField.classList.add("has-error");
        const percentLabel = document.createElement("label");
        percentLabel.textContent = "Completion %";
        percentField.appendChild(percentLabel);
        percentField.appendChild(percent);
        if (percentError) {
          const error = document.createElement("div");
          error.className = "field-error";
          error.textContent = percentError;
          percentField.appendChild(error);
        }

        const hoursField = document.createElement("div");
        hoursField.className = "meta-field";
        const hoursError = getFieldError(eodDraft, editorId, "spentHours");
        if (hoursError) hoursField.classList.add("has-error");
        const hoursLabel = document.createElement("label");
        hoursLabel.textContent = "Hours";
        hoursField.appendChild(hoursLabel);
        hoursField.appendChild(spentHours);
        if (hoursError) {
          const error = document.createElement("div");
          error.className = "field-error";
          error.textContent = hoursError;
          hoursField.appendChild(error);
        }

        const minsField = document.createElement("div");
        minsField.className = "meta-field";
        const minsError = getFieldError(eodDraft, editorId, "spentMinutes");
        if (minsError) minsField.classList.add("has-error");
        const minsLabel = document.createElement("label");
        minsLabel.textContent = "Minutes";
        minsField.appendChild(minsLabel);
        minsField.appendChild(spentMinutes);
        if (minsError) {
          const error = document.createElement("div");
          error.className = "field-error";
          error.textContent = minsError;
          minsField.appendChild(error);
        }

        const noteField = document.createElement("div");
        noteField.className = "meta-field note-field";
        const noteLabel = document.createElement("label");
        noteLabel.textContent = "Progress Note";
        noteField.appendChild(noteLabel);
        noteField.appendChild(note);

        meta.appendChild(percentField);
        meta.appendChild(hoursField);
        meta.appendChild(minsField);
        meta.appendChild(noteField);
        row.appendChild(meta);
        head.style.cursor = "pointer";
        head.addEventListener("click", (event) => {
          if (event.target.closest("input[type=\"checkbox\"]")) return;
          if (!checkbox.checked) {
            checkbox.checked = true;
            eodDraft.selectedTaskIds[task.taskId] = true;
            if (!eodDraft.updatesByTaskId[task.taskId]) {
              eodDraft.updatesByTaskId[task.taskId] = { completionPercent: "", spentHours: "", spentMinutes: "", note: "" };
            }
          }
          eodDraft.activeEditorId = editorId;
          saveState();
          renderEodTasks();
          updateSummaryCards();
        });

        checkbox.addEventListener("change", () => {
          if (checkbox.checked) {
            eodDraft.selectedTaskIds[task.taskId] = true;
            if (!eodDraft.updatesByTaskId[task.taskId]) {
              eodDraft.updatesByTaskId[task.taskId] = { completionPercent: "", spentHours: "", spentMinutes: "", note: "" };
            }
            eodDraft.activeEditorId = editorId;
          } else {
            delete eodDraft.selectedTaskIds[task.taskId];
            delete eodDraft.updatesByTaskId[task.taskId];
            if (eodDraft.activeEditorId === editorId) {
              eodDraft.activeEditorId = "";
            }
          }
          saveState();
          renderEodTasks();
          updateSummaryCards();
        });

        percent.addEventListener("input", () => {
          const value = percent.value;
          if (!eodDraft.updatesByTaskId[task.taskId]) {
            eodDraft.updatesByTaskId[task.taskId] = { completionPercent: "", spentHours: "", spentMinutes: "", note: "" };
          }
          eodDraft.updatesByTaskId[task.taskId].completionPercent = value;
          clearFieldError(eodDraft, editorId, "completionPercent");
          saveState();
          updateSummaryCards();
        });

        spentHours.addEventListener("input", () => {
          if (!eodDraft.updatesByTaskId[task.taskId]) {
            eodDraft.updatesByTaskId[task.taskId] = { completionPercent: "", spentHours: "", spentMinutes: "", note: "" };
          }
          eodDraft.updatesByTaskId[task.taskId].spentHours = spentHours.value;
          clearFieldError(eodDraft, editorId, "spentHours");
          saveState();
          updateSummaryCards();
        });

        spentMinutes.addEventListener("input", () => {
          if (!eodDraft.updatesByTaskId[task.taskId]) {
            eodDraft.updatesByTaskId[task.taskId] = { completionPercent: "", spentHours: "", spentMinutes: "", note: "" };
          }
          eodDraft.updatesByTaskId[task.taskId].spentMinutes = spentMinutes.value;
          clearFieldError(eodDraft, editorId, "spentMinutes");
          saveState();
          updateSummaryCards();
        });

        note.addEventListener("input", () => {
          if (!eodDraft.updatesByTaskId[task.taskId]) {
            eodDraft.updatesByTaskId[task.taskId] = { completionPercent: "", spentHours: "", spentMinutes: "", note: "" };
          }
          eodDraft.updatesByTaskId[task.taskId].note = note.value;
          saveState();
        });

        eodTasksEl.appendChild(row);
      });

      eodDraft.extras.forEach((extra, index) => {
        const extraId = extra.taskId || createTaskId();
        extra.taskId = extraId;
        const editorId = `extra:${extraId}`;
        const row = document.createElement("div");
        row.className = "extra-row";

        const head = document.createElement("div");
        head.className = "extra-row-head";
        const titleWrap = document.createElement("div");
        titleWrap.className = "task-title-wrap";
        const sr = document.createElement("span");
        sr.className = "sr-badge";
        sr.textContent = `#${String(index + 1).padStart(2, "0")}`;
        const title = document.createElement("div");
        title.className = "task-title";
        title.textContent = `Extra Task ${index + 1}`;
        titleWrap.appendChild(sr);
        titleWrap.appendChild(title);

        const remove = document.createElement("button");
        remove.type = "button";
        remove.className = "danger icon-danger";
        remove.title = "Remove task";
        remove.setAttribute("aria-label", "Remove task");
        remove.innerHTML = "<i class=\"fa-solid fa-trash\"></i>";
        remove.addEventListener("click", () => {
          eodDraft.extras.splice(index, 1);
          saveState();
          renderEodTasks();
          updateSummaryCards();
        });

        head.appendChild(titleWrap);
        head.appendChild(remove);
        row.appendChild(head);

        const titleInput = document.createElement("input");
        titleInput.type = "text";
        titleInput.placeholder = "Extra task title";
        titleInput.value = extra.title || "";

        const meta = document.createElement("div");
        meta.className = "extra-meta";
        meta.style.display = activeEditorId === editorId ? "grid" : "none";
        const percent = document.createElement("select");
        percent.innerHTML = buildCompletionOptionsMarkup(COMPLETION_OPTIONS);
        percent.value = extra.completionPercent == null ? "" : String(extra.completionPercent);
        percent.dataset.editorId = editorId;
        percent.dataset.field = "completionPercent";

        const spentHours = document.createElement("input");
        spentHours.type = "number";
        spentHours.min = "0";
        spentHours.placeholder = "Hours";
        spentHours.value = extra.spentHours ?? "";
        spentHours.dataset.editorId = editorId;
        spentHours.dataset.field = "spentHours";

        const spentMinutes = document.createElement("input");
        spentMinutes.type = "number";
        spentMinutes.min = "0";
        spentMinutes.max = "59";
        spentMinutes.placeholder = "Minutes";
        spentMinutes.value = extra.spentMinutes ?? "";
        spentMinutes.dataset.editorId = editorId;
        spentMinutes.dataset.field = "spentMinutes";

        const note = document.createElement("textarea");
        note.placeholder = "Optional progress note";
        note.value = extra.note || "";
        note.dataset.editorId = editorId;
        note.dataset.field = "note";

        const percentField = document.createElement("div");
        percentField.className = "meta-field";
        const percentError = getFieldError(eodDraft, editorId, "completionPercent");
        if (percentError) percentField.classList.add("has-error");
        const percentLabel = document.createElement("label");
        percentLabel.textContent = "Completion %";
        percentField.appendChild(percentLabel);
        percentField.appendChild(percent);
        if (percentError) {
          const error = document.createElement("div");
          error.className = "field-error";
          error.textContent = percentError;
          percentField.appendChild(error);
        }

        const hoursField = document.createElement("div");
        hoursField.className = "meta-field";
        const hoursError = getFieldError(eodDraft, editorId, "spentHours");
        if (hoursError) hoursField.classList.add("has-error");
        const hoursLabel = document.createElement("label");
        hoursLabel.textContent = "Hours";
        hoursField.appendChild(hoursLabel);
        hoursField.appendChild(spentHours);
        if (hoursError) {
          const error = document.createElement("div");
          error.className = "field-error";
          error.textContent = hoursError;
          hoursField.appendChild(error);
        }

        const minsField = document.createElement("div");
        minsField.className = "meta-field";
        const minsError = getFieldError(eodDraft, editorId, "spentMinutes");
        if (minsError) minsField.classList.add("has-error");
        const minsLabel = document.createElement("label");
        minsLabel.textContent = "Minutes";
        minsField.appendChild(minsLabel);
        minsField.appendChild(spentMinutes);
        if (minsError) {
          const error = document.createElement("div");
          error.className = "field-error";
          error.textContent = minsError;
          minsField.appendChild(error);
        }

        const noteField = document.createElement("div");
        noteField.className = "meta-field note-field";
        const noteLabel = document.createElement("label");
        noteLabel.textContent = "Progress Note";
        noteField.appendChild(noteLabel);
        noteField.appendChild(note);

        meta.appendChild(percentField);
        meta.appendChild(hoursField);
        meta.appendChild(minsField);
        meta.appendChild(noteField);
        row.appendChild(titleInput);
        row.appendChild(meta);
        head.style.cursor = "pointer";
        head.addEventListener("click", () => {
          eodDraft.activeEditorId = editorId;
          saveState();
          renderEodTasks();
          updateSummaryCards();
        });

        titleInput.addEventListener("input", () => {
          extra.title = titleInput.value;
          eodDraft.activeEditorId = editorId;
          saveState();
          updateSummaryCards();
        });
        percent.addEventListener("input", () => {
          extra.completionPercent = percent.value;
          eodDraft.activeEditorId = editorId;
          clearFieldError(eodDraft, editorId, "completionPercent");
          saveState();
          updateSummaryCards();
        });
        spentHours.addEventListener("input", () => {
          extra.spentHours = spentHours.value;
          eodDraft.activeEditorId = editorId;
          clearFieldError(eodDraft, editorId, "spentHours");
          saveState();
          updateSummaryCards();
        });
        spentMinutes.addEventListener("input", () => {
          extra.spentMinutes = spentMinutes.value;
          eodDraft.activeEditorId = editorId;
          clearFieldError(eodDraft, editorId, "spentMinutes");
          saveState();
          updateSummaryCards();
        });
        note.addEventListener("input", () => {
          extra.note = note.value;
          eodDraft.activeEditorId = editorId;
          saveState();
        });

        eodTasksEl.appendChild(row);
      });
    }

    function renderAll() {
      renderSodSourceHint();
      renderSyncMeta();
      renderStartTasks();
      renderEodTasks();
      updateSummaryCards();
    }

    function addTaskToStartDraft() {
      const dateKey = workDateEl.value;
      const title = newTaskTitleEl.value.trim();
      if (!title) {
        setStatus(sodStatusEl, "Task title is required.", "error");
        return;
      }

      const draft = getOrCreateStartDraft(dateKey);
      draft.push({
        taskId: createTaskId(),
        title,
        priority: normalizePriority(newTaskPriorityEl.value),
        source: "sod"
      });
      state.startSourceByDate[dateKey] = "local-storage";

      newTaskTitleEl.value = "";
      newTaskPriorityEl.value = "Medium";
      setStatus(sodStatusEl, "", "");
      saveState();
      renderAll();
    }

    async function handleSodSubmit() {
      const dateKey = workDateEl.value;
      const draftTasks = getOrCreateStartDraft(dateKey);
      const tasksForState = draftTasks
        .map((t) => ({
          taskId: t.taskId || createTaskId(),
          title: (t.title || "").trim(),
          priority: normalizePriority(t.priority),
          source: isCarryoverTask(t) ? "carryover" : (isAssignedTask(t) ? "assigned" : "sod"),
          lastCompletion: getCarryoverLastCompletion(t),
          lastNote: (t.lastNote || "").trim(),
          carryoverOrigin: isCarryoverTask(t) ? String(t.carryoverOrigin || "local-storage") : "",
          assignedBy: isAssignedTask(t) ? String(t.assignedBy || "").trim() : ""
        }))
        .filter((t) => t.title.length > 0);
      const tasks = tasksForState.map((t) => ({
        taskId: t.taskId,
        title: t.title,
        priority: t.priority
      }));

      if (!tasks.length) {
        setStatus(sodStatusEl, "Add at least one task before Start-of-Day submit.", "error");
        return;
      }

      setStatus(sodStatusEl, "Submitting Start-of-Day...", "");
      submitSodBtn.disabled = true;
      try {
        const payload = {
          stage: "SOD",
          requestId: createRequestId(),
          payloadVersion: "v2",
          submittedAt: new Date().toISOString(),
          workDate: dateKey,
          department: identity.dept,
          employeeName: identity.name,
          accessCode: identity.code,
          tasks,
          clientVersion: CLIENT_VERSION
        };
        const result = await callApi("submitSOD", payload);
        if (!result || result.ok === false) {
          throw new Error(result && result.message ? result.message : "Start-of-Day submit rejected.");
        }

        state.sodByDate[dateKey] = tasksForState;
        state.eodSubmittedByDate[dateKey] = false;
        saveState();
        const zoho = await sendZohoFlow("SOD", payload);
        if (result.transport === "no-cors") {
          if (!zoho.skipped && zoho.ok) {
            setStatus(sodStatusEl, "Start-of-Day sent to Apps Script and Zoho Flow (request transport: no-cors).", "info");
          } else if (zoho.skipped) {
            setStatus(sodStatusEl, "Start-of-Day request sent. If sheet is not updated, check Apps Script deployment permissions.", "info");
          } else {
            setStatus(sodStatusEl, "Start-of-Day sent to Apps Script, but Zoho Flow webhook failed.", "info");
          }
        } else {
          if (!zoho.skipped && zoho.ok) {
            setStatus(sodStatusEl, "Start-of-Day submitted successfully (Apps Script + Zoho Flow).", "success");
          } else if (zoho.skipped) {
            setStatus(sodStatusEl, "Start-of-Day submitted successfully.", "success");
          } else {
            setStatus(sodStatusEl, "Start-of-Day submitted to Apps Script, but Zoho Flow webhook failed.", "info");
          }
        }
        renderAll();
      } catch (err) {
        setStatus(sodStatusEl, `Start-of-Day submit failed: ${err.message}`, "error");
      } finally {
        submitSodBtn.disabled = false;
      }
    }

    function parsePercent(value) {
      const n = Number(value);
      const allowed = new Set(COMPLETION_OPTIONS);
      if (!Number.isFinite(n)) return null;
      return allowed.has(n) ? n : null;
    }

    function parseHours(value) {
      if (value == null || String(value).trim() === "") return 0;
      const n = Number(value);
      if (!Number.isFinite(n) || n < 0) return null;
      return Math.floor(n);
    }

    function parseMinutes(value) {
      if (value == null || String(value).trim() === "") return 0;
      const n = Number(value);
      if (!Number.isFinite(n) || n < 0 || n > 59) return null;
      return Math.floor(n);
    }

    function formatMinutes(totalMinutes) {
      const safe = Math.max(0, totalMinutes || 0);
      const h = Math.floor(safe / 60);
      const m = safe % 60;
      return `${h}h ${m}m`;
    }

    function formatDateLabel(isoDate) {
      if (!isoDate || !isoDate.includes("-")) return isoDate || "-";
      const [y, m, d] = isoDate.split("-");
      return `${d}-${m}-${y}`;
    }

    function buildCliqMessage(stage, payload) {
      const header = `*${payload.employeeName || "-"}* ${stage === "EOD" ? "End of Day" : "Start of Day"} Update (${formatDateLabel(payload.workDate)})`;
      const meta = `Dept: ${payload.department || "-"} | Date: ${payload.workDate || "-"}${stage === "EOD" ? ` | Total Time: ${formatMinutes(payload.totalSpentMinutes || 0)}` : ""}`;
      const list = stage === "EOD"
        ? (payload.updates || []).map((t, i) => {
            const spent = `${t.spentHours || 0}h ${t.spentMinutes || 0}m`;
            return `${i + 1}. ${t.title || "-"} [${t.priority || "Medium"}]\n   Completion: ${t.completionPercent}% | Spent: ${spent}${t.note ? `\n   Note: ${t.note}` : ""}`;
          })
        : (payload.tasks || []).map((t, i) => `${i + 1}. ${t.title || "-"} [${t.priority || "Medium"}]`);
      return [header, meta, "", "*Tasks:*", ...list].join("\n");
    }

    async function sendZohoFlow(stage, payload) {
      if (!ZOHO_FLOW_WEBHOOK_URL) return { skipped: true };
      const cliqMessage = buildCliqMessage(stage, payload);
      const flowPayload = {
        stage,
        employeeName: payload.employeeName,
        department: payload.department,
        workDate: payload.workDate,
        accessCode: payload.accessCode,
        taskCount: stage === "EOD" ? (payload.updates || []).length : (payload.tasks || []).length,
        totalSpentMinutes: payload.totalSpentMinutes || 0,
        cliq_message: cliqMessage,
        payload_json: JSON.stringify(payload)
      };

      try {
        await fetch(ZOHO_FLOW_WEBHOOK_URL, {
          method: "POST",
          mode: "no-cors",
          headers: { "Content-Type": "application/x-www-form-urlencoded;charset=UTF-8" },
          body: toFormEncoded(flowPayload),
          keepalive: true
        });
        return { ok: true };
      } catch (err) {
        return { ok: false, message: String(err && err.message ? err.message : err) };
      }
    }

    function updateSummaryCards() {
      const dateKey = workDateEl.value;
      const startTasks = getOrCreateStartDraft(dateKey);
      const pending = getPendingTasksForDate(dateKey);
      const eodDraft = getOrCreateEodDraft(dateKey);

      let selectedCount = 0;
      let totalSpent = 0;

      pending.forEach((task) => {
        if (!eodDraft.selectedTaskIds[task.taskId]) return;
        selectedCount += 1;
        const upd = eodDraft.updatesByTaskId[task.taskId] || {};
        const h = parseHours(upd.spentHours);
        const m = parseMinutes(upd.spentMinutes);
        if (h !== null && m !== null) {
          totalSpent += h * 60 + m;
        }
      });

      (eodDraft.extras || []).forEach((extra) => {
        if (!(extra.title || "").trim()) return;
        selectedCount += 1;
        const h = parseHours(extra.spentHours);
        const m = parseMinutes(extra.spentMinutes);
        if (h !== null && m !== null) {
          totalSpent += h * 60 + m;
        }
      });

      startCountCardEl.textContent = String(startTasks.length);
      endCountCardEl.textContent = String(selectedCount);
      hoursSplitCardEl.textContent = formatMinutes(totalSpent);
    }

    function validateEodBeforeSubmit(pending, eodDraft) {
      for (const task of pending) {
        if (!eodDraft.selectedTaskIds[task.taskId]) continue;
        const editorId = `pending:${task.taskId}`;
        const update = eodDraft.updatesByTaskId[task.taskId] || {};
        const allowed = getAllowedCompletionOptions(task);
        const completion = parsePercent(update.completionPercent);
        if (completion === null || !allowed.includes(completion)) {
          return {
            ok: false,
            editorId,
            field: "completionPercent",
            message: "Choose a valid completion %. Carryover tasks must move strictly above previous completion."
          };
        }

        const hRaw = update.spentHours;
        const mRaw = update.spentMinutes;
        const h = parseHours(hRaw);
        const m = parseMinutes(mRaw);
        if (h === null) {
          return { ok: false, editorId, field: "spentHours", message: "Hours must be a valid number (0 or above)." };
        }
        if (m === null) {
          return { ok: false, editorId, field: "spentMinutes", message: "Minutes must be between 0 and 59." };
        }
        const hasAnyTimeInput = String(hRaw ?? "").trim() !== "" || String(mRaw ?? "").trim() !== "";
        if (!hasAnyTimeInput || (h === 0 && m === 0)) {
          return { ok: false, editorId, field: "spentHours", message: "Dedicated time is required. Enter hours/minutes greater than zero." };
        }
      }

      for (const extra of eodDraft.extras || []) {
        const title = (extra.title || "").trim();
        if (!title) continue;
        const editorId = `extra:${extra.taskId}`;
        const completion = parsePercent(extra.completionPercent);
        if (completion === null) {
          return { ok: false, editorId, field: "completionPercent", message: "Choose a valid completion % for extra tasks." };
        }
        const hRaw = extra.spentHours;
        const mRaw = extra.spentMinutes;
        const h = parseHours(hRaw);
        const m = parseMinutes(mRaw);
        if (h === null) {
          return { ok: false, editorId, field: "spentHours", message: "Hours must be a valid number (0 or above)." };
        }
        if (m === null) {
          return { ok: false, editorId, field: "spentMinutes", message: "Minutes must be between 0 and 59." };
        }
        const hasAnyTimeInput = String(hRaw ?? "").trim() !== "" || String(mRaw ?? "").trim() !== "";
        if (!hasAnyTimeInput || (h === 0 && m === 0)) {
          return { ok: false, editorId, field: "spentHours", message: "Dedicated time is required for extra tasks." };
        }
      }

      return { ok: true };
    }

    async function handleEodSubmit() {
      const dateKey = workDateEl.value;
      const pending = getPendingTasksForDate(dateKey);
      const eodDraft = getOrCreateEodDraft(dateKey);
      eodDraft.fieldErrors = {};

      const precheck = validateEodBeforeSubmit(pending, eodDraft);
      if (!precheck.ok) {
        eodDraft.activeEditorId = precheck.editorId;
        setFieldError(eodDraft, precheck.editorId, precheck.field, precheck.message);
        saveState();
        renderEodTasks();
        focusEditorField(precheck.editorId, precheck.field);
        setStatus(eodStatusEl, precheck.message, "error");
        return;
      }

      const selectedUpdates = pending
        .filter((t) => eodDraft.selectedTaskIds[t.taskId])
        .map((t) => {
          const update = eodDraft.updatesByTaskId[t.taskId] || {};
          return {
            taskId: t.taskId,
            title: t.title,
            completionPercent: parsePercent(update.completionPercent),
            spentHours: parseHours(update.spentHours),
            spentMinutes: parseMinutes(update.spentMinutes),
            note: (update.note || "").trim(),
            priority: normalizePriority(t.priority),
            isExtra: false
          };
        });

      const validExtras = (eodDraft.extras || [])
        .map((e) => ({
          taskId: e.taskId || createTaskId(),
          title: (e.title || "").trim(),
          completionPercent: parsePercent(e.completionPercent),
          spentHours: parseHours(e.spentHours),
          spentMinutes: parseMinutes(e.spentMinutes),
          note: (e.note || "").trim(),
          priority: normalizePriority(e.priority),
          isExtra: true
        }))
        .filter((e) => e.title.length > 0);

      const updates = [...selectedUpdates, ...validExtras];
      if (!updates.length) {
        setStatus(eodStatusEl, "Select at least one pending task or add an extra task.", "error");
        return;
      }

      const hasInvalid = updates.some(
        (u) => u.completionPercent === null || u.spentHours === null || u.spentMinutes === null
      );
      if (hasInvalid) {
        setStatus(eodStatusEl, "Completion % and dedicated time must be valid for every submitted task.", "error");
        return;
      }

      setStatus(eodStatusEl, "Submitting End-of-Day...", "");
      submitEodBtn.disabled = true;
      try {
        const totalSpentMinutes = updates.reduce(
          (sum, u) => sum + ((u.spentHours || 0) * 60) + (u.spentMinutes || 0),
          0
        );
        const completed100Count = updates.filter((u) => u.completionPercent === 100).length;
        const carryForwardCount = updates.filter((u) => u.completionPercent < 100).length;
        const extraCount = updates.filter((u) => u.isExtra).length;
        const dailySummary = {
          plannedCount: pending.length,
          submittedCount: updates.length,
          completed100Count,
          carryForwardCount,
          extraCount,
          totalSpentMinutes
        };
        const payload = {
          stage: "EOD",
          requestId: createRequestId(),
          payloadVersion: "v2",
          submittedAt: new Date().toISOString(),
          workDate: dateKey,
          department: identity.dept,
          employeeName: identity.name,
          accessCode: identity.code,
          totalSpentMinutes,
          dailySummary,
          updates,
          clientVersion: CLIENT_VERSION
        };

        const result = await callApi("submitEOD", payload);
        if (!result || result.ok === false) {
          throw new Error(result && result.message ? result.message : "End-of-Day submit rejected.");
        }

        const nextDate = nextDateISO(dateKey);
        const incomplete = updates
          .filter((u) => u.completionPercent < 100)
          .map((u) => ({
            taskId: u.taskId,
            title: u.title,
            priority: u.priority,
            source: "carryover",
            carryFrom: dateKey,
            lastCompletion: u.completionPercent,
            lastNote: u.note,
            carryoverOrigin: "local-storage"
          }));

        if (incomplete.length) {
          state.carryoverByDate[nextDate] = incomplete;
          state.carryoverSourceByDate[nextDate] = "local-storage";
          state.startSourceByDate[nextDate] = "local-storage";
          mergeCarryoverIntoStartDraft(nextDate, incomplete);
        } else if (Array.isArray(state.carryoverByDate[nextDate])) {
          delete state.carryoverByDate[nextDate];
          delete state.carryoverSourceByDate[nextDate];
        }
        state.eodSubmittedByDate[dateKey] = true;
        state.carryoverSyncedByDate[nextDate] = false;
        state.carryoverSyncedByDate[dateKey] = true;
        delete state.carryoverByDate[dateKey];
        delete state.carryoverSourceByDate[dateKey];

        state.eodDraftByDate[dateKey] = { selectedTaskIds: {}, updatesByTaskId: {}, extras: [], activeEditorId: "", fieldErrors: {} };
        state.workDate = nextDate;
        workDateEl.value = nextDate;
        getOrCreateEodDraft(nextDate);
        saveState();
        const zoho = await sendZohoFlow("EOD", payload);
        if (result.transport === "no-cors") {
          if (!zoho.skipped && zoho.ok) {
            setStatus(eodStatusEl, "End-of-Day sent to Apps Script and Zoho Flow (request transport: no-cors).", "info");
          } else if (zoho.skipped) {
            setStatus(eodStatusEl, "End-of-Day request sent. If sheet is not updated, check Apps Script deployment permissions.", "info");
          } else {
            setStatus(eodStatusEl, "End-of-Day sent to Apps Script, but Zoho Flow webhook failed.", "info");
          }
        } else {
          if (!zoho.skipped && zoho.ok) {
            setStatus(eodStatusEl, "End-of-Day submitted successfully (Apps Script + Zoho Flow).", "success");
          } else if (zoho.skipped) {
            setStatus(eodStatusEl, "End-of-Day submitted successfully.", "success");
          } else {
            setStatus(eodStatusEl, "End-of-Day submitted to Apps Script, but Zoho Flow webhook failed.", "info");
          }
        }
        renderAll();
      } catch (err) {
        setStatus(eodStatusEl, `End-of-Day submit failed: ${err.message}`, "error");
      } finally {
        submitEodBtn.disabled = false;
      }
    }

    async function validateAccessOrBlock() {
      const params = getAccessParams();
      if (!params.dept || !params.name || !params.code) {
        showBlocked("Missing URL parameters. Please use a full link with dept, name, and code.");
        return false;
      }
      const deptUsers = USER_DIRECTORY[params.dept];
      if (!deptUsers) {
        showBlocked("Invalid department in link.");
        return false;
      }
      const expectedCode = deptUsers[params.name];
      if (!expectedCode) {
        showBlocked("Invalid name for this department.");
        return false;
      }
      if (params.code !== expectedCode) {
        showBlocked("Invalid access code.");
        return false;
      }
      identity = {
        dept: params.dept,
        name: params.name,
        code: params.code
      };
      return true;
    }

    function wireEvents() {
      workDateEl.addEventListener("change", async () => {
        state.workDate = workDateEl.value;
        getOrCreateStartDraft(workDateEl.value);
        getOrCreateEodDraft(workDateEl.value);
        hydrateCarryoverFromUnsubmittedSod(workDateEl.value);
        await syncCarryoverFromSheets(workDateEl.value, false);
        await syncAssignmentsFromAdmin(workDateEl.value, false);
        saveState();
        setStatus(sodStatusEl, "", "");
        setStatus(eodStatusEl, "", "");
        renderAll();
      });

      addTaskBtn.addEventListener("click", addTaskToStartDraft);
      newTaskTitleEl.addEventListener("keydown", (event) => {
        if (event.key === "Enter") {
          event.preventDefault();
          addTaskToStartDraft();
        }
      });

      submitSodBtn.addEventListener("click", handleSodSubmit);
      submitEodBtn.addEventListener("click", handleEodSubmit);
      syncCarryoverBtn.addEventListener("click", async () => {
        const dateKey = workDateEl.value;
        setButtonLoading(syncCarryoverBtn, true, "Syncing...", "<i class=\"fa-solid fa-rotate\"></i>Sync Now");
        try {
          state.carryoverSyncedByDate[dateKey] = false;
          state.assignmentSyncedByDate[dateKey] = false;
          await syncCarryoverFromSheets(dateKey, true);
          await syncAssignmentsFromAdmin(dateKey, true);
          const status = state.syncMetaByDate[dateKey] && state.syncMetaByDate[dateKey].status;
          if (status === "success") {
            showToast("Sync complete.", "success");
          } else if (status === "fallback") {
            showToast("Google carryover sync failed. Using local fallback.", "info");
          } else if (status === "error") {
            showToast("Carryover sync failed.", "error");
          } else {
            showToast("Sync finished.", "info");
          }
          renderAll();
        } catch (err) {
          showToast(`Sync failed: ${err.message}`, "error");
        } finally {
          setButtonLoading(syncCarryoverBtn, false, "", "<i class=\"fa-solid fa-rotate\"></i>Sync Now");
        }
      });
      copySummaryLinkBtn.addEventListener("click", async () => {
        setButtonLoading(copySummaryLinkBtn, true, "Copying...", "<i class=\"fa-solid fa-link\"></i>Copy Summary Link");
        const params = new URLSearchParams({
          dept: identity.dept,
          name: identity.name,
          code: identity.code,
          date: workDateEl.value,
          view: "summary"
        });
        const link = `${window.location.origin}${window.location.pathname}?${params.toString()}`;
        try {
          if (navigator.clipboard && navigator.clipboard.writeText) {
            await navigator.clipboard.writeText(link);
          } else {
            const ta = document.createElement("textarea");
            ta.value = link;
            document.body.appendChild(ta);
            ta.select();
            document.execCommand("copy");
            document.body.removeChild(ta);
          }
          showToast("Summary link copied.", "success");
        } catch (err) {
          showToast("Could not copy summary link.", "error");
        } finally {
          setButtonLoading(copySummaryLinkBtn, false, "", "<i class=\"fa-solid fa-link\"></i>Copy Summary Link");
        }
      });

      addExtraBtn.addEventListener("click", () => {
        const dateKey = workDateEl.value;
        const eodDraft = getOrCreateEodDraft(dateKey);
        eodDraft.extras.push({
          taskId: createTaskId(),
          title: "",
          completionPercent: "",
          spentHours: "",
          spentMinutes: "",
          note: "",
          priority: "Medium"
        });
        const last = eodDraft.extras[eodDraft.extras.length - 1];
        eodDraft.activeEditorId = `extra:${last.taskId}`;
        saveState();
        renderEodTasks();
        updateSummaryCards();
      });
    }

    async function init() {
      const ok = await validateAccessOrBlock();
      if (!ok) return;

      nameLineEl.textContent = identity.name;
      deptLineEl.textContent = `Department: ${identity.dept}`;
      state = loadState();
      if (!state.workDate) {
        state.workDate = todayISO();
      }
      workDateEl.value = state.workDate;

      getOrCreateStartDraft(workDateEl.value);
      getOrCreateEodDraft(workDateEl.value);
      hydrateCarryoverFromUnsubmittedSod(workDateEl.value);
      await syncCarryoverFromSheets(workDateEl.value, false);
      await syncAssignmentsFromAdmin(workDateEl.value, false);

      wireEvents();
      renderAll();
      saveState();
      appEl.hidden = false;
    }

    init();
  </script>
</body>
</html>
